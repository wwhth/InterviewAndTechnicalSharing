## 浏览器渲染过程
### 创建DOM树    
使用HTML分析器，使HTML元素字节流转换为DOM结构，构成DOM树（标记化）    

DOM树的构建不需要等整个HTML加载完成之后再开始，而是网络进程加载了多少数据，HTML解析器就解析多少数据  

*DOM树的简单生成过程：HTML字节流 -> 分词器 -> DOM节点 -> DOM树节点*  

通过分词器将字节流转化成Token（类似于虚拟DOM结构） 

至于后续的第二个和第三个阶段是同步进行的，需要将 Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中。    

DOM树在浏览器内部生成使用的是DFS深度优先算法.   

> HTML解析器维护了一个token栈的结构，主要用来计算节点之间的父子级关系，在第一个阶段生成的token会被压入到这个栈中，规则：   
    > 1. 如果该token是一个start token，HTML解析器会为其创建一个DOM节点，然后将该节点压入到DOM树中，它的父节点就是栈中相邻节点生成的节点
    > 2. 如果分词器解析出来是文本 Token，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。
    > 3. 如果分词器解析出来的是 EndTag 标签，比如是 EndTag div，HTML 解析器会查看 Token 栈顶的元素是否是 StarTag div，如果是，就将 StartTag div 从栈中弹出，表示该 div 元素解析完成。


### 创建styleRule
使用CSS分析器，分析css文件与inline样式，生成样式表
CSS 的解析是从右往左逆向解析的(从 DOM树的下－上解析比上－下解析效率高)，嵌套标签越多，解析越慢。

### 创建Render树
将DOM树与样式表关联起来，构建一棵render树，每个DOM节点都有attach方法接受样式信息，返回render对象，这些render对象最终会构成render树

> 前面三部不是完全独立，会有交叉，一边加载，一边解析，一边渲染

### 布局Layout（重排）
浏览器开始布局，为每个render树的节点确定一个在显示屏上的精确坐标

### 绘制painting（重绘）
调用每个节点的paint方法，将节点绘制出来

- 补充：    
  1. 重绘：当元素属性发生改变不影响布局的时候，产生重绘，不刷新页面，动态更新内容；    
  2. 回流：当元素的属性改变影响布局的时候，刷新页面更新内容。
  > 重绘不一定引起回流，回流必将引起重绘    
  3. 如何减少回流和重绘
    > - 使用 transform 替代 top   
    > - 使用 visibility 替换 display: none     ，因为前者只会引起重绘，后者会引发回流（改变了布局）    
    > - 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局    
    > - 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用requestAnimationFrame   
    > - CSS 选择符从右往左匹配查找，避免节点层级过多  
    > - 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 video 标签来说，浏览器会自动将该节点变为图层。

 - 补充：浏览器的渲染进程：  
  首先浏览器进程有如下几部分：主进程，第三方插件进程，GPU进程，渲染进程。  
  而渲染进程又包含了很多线程：js引擎线程，事件触发线程，定时器触发线程，异步http请求线程，GUI渲染线程。 
  > - 主进程：负责页面的显示与交互，页面的管理（创建和销毁），网络资源的管理和下载  
  > - GPU进程：只有一个 负责3d的渲染    
  插件进程：每种插件对应的一个进程  
  > - 渲染器进程：浏览器渲染，内部是多线程的，主要负责页面的渲染，脚本的执行和事件处理等    
  > - GUI渲染线程：  
    >> 1. 解析html和css，形成dom树和cssom，构建render树，进行页面的布局和绘制；  
    >> 1. 当页面进行回流和重绘的时候是在执行这个线程； 
    >> 1. GUI线程与js引擎线程互斥，当js引擎线程执行时GUI会被挂起
  > - js引擎线程：负责解析js脚本，运行代码；因为与GUI线程互斥，所以一个js线程执行时间过长会导致页面渲染不连贯（阻塞页面的渲染）    
  > - 事件触发线程：    
    >> 1. 归于浏览器，而不是js引擎线程，控制事件循环； 
    >> 1. 当js引擎执行到settimeout等事件时，会将对应任务添加到事件线程，当对应的线程符合条件时会放到任务队列的末尾，等待js引擎线程的处理；    
    >> 1. 由于js引擎是单线程的原因，这些等待处理的事件都需要排队等待js引擎线程的处理    
  > - 定时触发器线程：  
    >> 1. settimeout和setinterval所在的线程    
    >> 1. 浏览器定时计数器不是由js引擎线程计数的，因此通过单独线程来计时触发定时，计时完毕后，添加到事件队列，等待js引擎执行。    
  > - 异步http请求线程：    
    >> 1. 在 XMLHttpRequest     在连接后是通过浏览器新开一个线程请求。  
    >> 1. 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由 JavaScript 引擎执行    

- 补充：css解析不会阻碍dom的解析，但是会阻碍dom的渲染，javascript文件的下载过程会阻碍DOM树的解析  
优化 JavaScript 影响 DOM 树生成的策略：      
    - CDN 来加速 JavaScript 文件的加载     
    - 压缩 JavaScript 文件的体积       
    - 异步加载     
        > - defer：脚本并行加载，等待HTML解析完成之后，按照加载顺序执行脚本，执行时机在DOMContentLoaded事件派发之前。必然不会阻碍html解析        
        > - async：使用 async 标志的脚本文件一旦加载完成，会立即执行，执行时机不确定，仍有可能阻塞HTML解析，执行时机在load事件派发之前
